/** Test checking the mesh serialization/deserialization works symmetrically.
 *
 * This test program will load a mesh from a file, compute its dual mesh, which it will then compare against a mesh
 * it loads from a manually checked output file and ensure the computed mesh is identical, except for positions array,
 * since that's made of floats, and it's not really prescribed what it should really be anyway for a dual mesh.
 *
 * Test program takes 2 or 3 command line arguments:
 *
 * argv[1] : Path to test file to load. It should be a file generated by CDUST, which was
 *     manually checked to be correct.
 *
 * argv[2] : Path to test file to load. It should be a file generated by CDUST, which was
 *     manually checked to be correct.
 *
 * argv[3] (optional): Path to output location where the mesh, which was loaded from argv[1], will be
 *     stored. This is to allow for easier inspection of files.
 *
 */

#include <errno.h>
#include <string.h>

#include "../test_common.h"
#include "../../src/mesh.h"
#include "../../src/io/mesh_io.h"



int main(int argc, char *argv[static restrict argc])
{
    if (argc < 2 || argc > 4) return 1;
    const char *in_mesh_path = argv[1];
    const char *cmp_mesh_path = argv[2];


    enum {chunk_size = 1 << 12};
    char *buffer = read_mesh_file_to_string(in_mesh_path, chunk_size);

    mesh_t *msh = deserialize_mesh(buffer, &TEST_ALLOCATOR);
    TEST_ASSERT(msh, "Mesh not deserialized");
    free(buffer);

    mesh_t *dual = mesh_dual_from_primal(msh, &TEST_ALLOCATOR);
    TEST_ASSERT(msh, "Dual failed");
    mesh_free(msh, &TEST_ALLOCATOR);


    if (argc == 4)
    {
        char *const str_out = serialize_mesh(dual, &TEST_ALLOCATOR);
        TEST_ASSERT(str_out, "Mesh not serialized");
        const size_t len = strlen(str_out);
        FILE *const f_out = fopen(argv[3], "w");
        TEST_ASSERT(f_out, "Output file %s not open, %s", argv[3], strerror(errno));
        TEST_ASSERT(fwrite(str_out, 1, len, f_out) == len, "Write not successful %s", strerror(errno));
        fclose(f_out);
        free(str_out);
    }

    buffer = read_mesh_file_to_string(cmp_mesh_path, chunk_size);
    mesh_t *cmp = deserialize_mesh(buffer, &TEST_ALLOCATOR);
    TEST_ASSERT(cmp, "Comparison not deserialized");
    free(buffer);


    TEST_ASSERT(cmp->n_points == dual->n_points, "Point counts do not match: %u vs %u", cmp->n_points, dual->n_points);
    TEST_ASSERT(cmp->n_lines == dual->n_lines, "Line counts do not match: %u vs %u", cmp->n_lines, dual->n_lines);
    TEST_ASSERT(cmp->n_surfaces == dual->n_surfaces, "Surface counts do not match: %u vs %u", cmp->n_surfaces, dual->n_surfaces);

    TEST_ASSERT(memcmp(cmp->lines, dual->lines, sizeof(*cmp->lines) * cmp->n_lines) == 0, "Comparison of line arrays failed.");
    for (unsigned i = 0; i < cmp->n_surfaces; ++i)
    {
        const surface_t *s1 = cmp->surfaces[i], *s2 = dual->surfaces[i];
        TEST_ASSERT(memcmp(s1, s2, sizeof(uint32_t) * s1->n_lines) == 0, "Comparison of surfaces.");
    }


    mesh_free(cmp, &TEST_ALLOCATOR);
    mesh_free(dual, &TEST_ALLOCATOR);



    return 0;
}
